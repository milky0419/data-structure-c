[README.md](https://github.com/user-attachments/files/21845306/README.ll.md)
# 단일 연결 리스트 (Linked List)

## 개념

### 연결 리스트란?

- 숫자를 입력할 때마다 숫자와 포인터를 **한 쌍으로 동적 할당하면서 계속 저장**하는 형식의 자료 구조

- 이때 동적 할당된 메모리는 **포인터로 연결** 되어 있음

- 데이터 저장 공간을 **낭비하지 않을 수 있**어, 자주 쓰임

### 연결 리스트 구현 방법

#### 1. 연결 리스트의 노드를 구조체로 선언하기

- **노드(Node)**: 숫자와 포인터를 함께 저장하기 위해 할당한 메모리

- 연결 리스트는 노드를 연결해서 데이터를 관리하기 때문에 노드에 해당하는 메모리를 **어떻게 구성할지 먼저 결정**해야 함

```c
typedef struct node // 노드(Node)
{
    int number; // 숫자를 저장할 변수
    struct node *p_next; // 다음 노드를 가리킬 포인터
} NODE;
```

#### 2. 연결 리스트에 노드를 추가하며 이어가기

##### 1단계: 이전 노드와 이후에 새로 추가되는 노드를 포인터로 연결하면서 확장

- **헤드 포인터(Head Pointer)**: 동적으로 할당되는 첫 노드의 주소 값을 저장할 포인터
  
  * **NODE** 형식으로 선언, **NULL로 초기화**

##### 2단계: 숫자를 저장하기 위한 새 노드 추가

1. 새로운 노드를 위한 메모리를 **`malloc` 을 사용**해 **동적으로 할당**

2. 할당된 **새 노드의 주소 값**을 **헤드 포인터에 저장**

3. 새로 할당된 노드에 입력된 값을 저장하고 **다음 노드를 가리킬 포인터**에 **NULL 대입**

```c
p_head = (NODE*)malloc(sizeof(NODE)); // 새 노드를 위한 메모리를 할당하고 주소 값을 헤드 포인터에 저장
p_head->number = 12; // 노드의 number에 값 12 저장
p_head->p_next = NULL; // 다음 노드가 없음을 명시
```

##### 3단계: 다른 숫자를 저장하기 위한 새 노드 추가

- **새로 추가되는 노드**는 두 번째 노드이기 때문에, 할당된 주소는 p_head가 아니라 **p_next에 저장**
1. 첫 노드의 주소 값은 p_head 포인터에 저장되어 있기 때문에 첫 노드의 p_next를 사용하기 위해 **'p_head->p_next' 사용**

2. 새로 할당된 노드의 **number(p_head->p_next->number)에 입력된 숫자를 저장**

3. p_next(p_head->p_next->p_next)에는 **NULL 대입**

```c
p_head->p_next = (NODE *)malloc(sizeof(NODE)); // 노드를 위한 메모리 할당
p_head->p_next->number = 15; // 노드의 number에 15를 저장
p_head->p_next->p_next = NULL; // 다음 노드가 없음을 명시
```

##### 반복문으로 연결 리스트에서 마지막 노드 탐색하기

- 연결 리스트에 노드를 새로 추가하면 기존에 구성된 노드 목록에서 가장 뒤쪽에 추가됨
  
  + 첫 노드의 주소 값은 p_head에 저장했지만 그다음 노드의 주소 값은 p_head->p_next에 저장하고 그다음 노드의 주소 값은 p_head->p_next->p->next에 저장
  
  + 결과적으로 여섯 번째 노드의 주소 값을 저장하기 위해 다음과 같이 코드를 작성해야 함
    
    ```c
    p_head->p_next->p_next->p_next->p_next->p_next = (NODE *)malloc(sizeof(NODE));
    ```
  
  + 하지만 해당 코드를 작성하는 것은 **너무 비효율적**임
  
  + p_next->의 작업이 일정하게 반복되기 때문에 해당 문제는 **반복문으로 해결 가능**
    
    ```c
    // 반복은 p_head에 저장된 주소 값에서 시작. p_head는 첫 노드의 주소 값 저장
    NODE *p = p_head;
    while (NULL != p->p_next) { // p_next가 NULL일 때까지 반복. p_next 값이 NULL이면 마지막 노드라는 뜻임
        p = p->p_next; // p->p_next 값을 p에 대입하면 p는 다음 노드의 주소로 이동
    } 
    ```
  
  + 위와 같은 코드를 작성하면 while문이 **한 번 반복할 때마다 p가 가리키는 노드의 다음 노드의 주소로 이동**

#### 3. 조건을 체크하여 연결 리스트에 새로운 노드 추가하기

- 연결 리스트에 **노드가 하나도 없는 경우(p_head가 NULL인 경우)를 체크하지 않으면 문제 발생**

- 따라서 **p_head가 NULL인지 여부를 체크**해서 처음 노드를 만드는 작업인지 구분해야 함

```c
void AddNumber (NODE **pp_head, int data)
{
    NODE *p;
    if (NULL != *pp_head) {
        p = *pp_head;

        while (NULL != p->p_next) // 마지막 노드를 찾기 위해서 p_next가 NULL일 때까지 반복
            p = p->next;
        p->p_next = (NODE *)malloc(sizeof(NODE); // 새 노드를 위한 메모리 할당
        p = p->p_next; // 새로 만든 노드의 주소 값을 p에 넣음
    } else { // p_head 값이 NULL이라서 첫 노드가 추가됨. p_head 값에 직접 대입함
        *pp_head = (NODE *)malloc(sizeof(NODE)); // 새 노드를 위한 메모리 할당
        p = *pp_head; // 새로 만든 노드의 주소 값을 p에 넣음
    }

    p->number = data; // 새 노드의 number에 data값을 저장
    p->p_next = NULL; // 다음 노드가 없음을 명시
}
```

- 연결 리스트에 새로운 노드를 추가하고 15라는 값을 저장하고 싶으면 다음과 같이 코드 구성

```c
NODE *p_head = NULL;
AddNumber (&p_head, 15);
```

#### 4. 연결 리스트의 마지막 노드 기억하기

- 앞에서 정의한 `AddNumber()`는 노드가 추가될 때마다 마지막 노드를 찾기 위해 탐색을 해야 한다는 **단점**이 있음 (**시간이 오래 걸림**)

- **테일 포인터(Tail Pointer)**: 앞에서 말한 단점을 보완하기 위한 포인터, **마지막 노드의 주소 값 저장**

- `AddNumber()` 에 테일 포인터 p_tail을 사용하여 코드를 수정하면 다음과 같음

```c
void AddNumber (NODE **pp_head, NODE **pp_tail, int data)
{
    if (NULL != *pp_head) {
        (*pp_tail)->p_next = (NODE *)malloc(sizeof(NODE); // 새 노드의 메모리 할당
        *pp_tail = (*pp_tail)->p_next; // p_tail(**pp_tail)에 새 노드의 주소 값을 저장
    } else {
        *pp_head = (NODE *)malloc(sizeof(NODE)); // 새 노드의 메모리 할당
        *pp_tail = *pp_head; // 새 노드의 주소 값을 p_tail(*pp_tail)에 저장
    }

    (*pp_tail)->number = data; // 새 노드의 number에 data 값 저장
    (*pp_tail)->p_next = NULL; // 다음 노드가 없음을 명시
}
```

- 테일 포인터를 사용하면 **반복문을 사용할 필요가 없**기 때문에 **훨씬 효율적**임

#### 5. 연결 리스트의 전체 노드 제거하기

- 첫 노드부터 마지막 노드까지 반복하면서 노드의 주소 값을 저장하기 위해 할당된 메모리를 하나씩 해제

- **p가 가리키는 대상 메모리를 해제하기 전에 p->p_next에 저장된 주소 값을 다른 포인터 변수로 옮겨 놓고 해제하기**

```c
NODE *p;

while (NULL != p_head) { // 시작 노드부터 마지막 노드까지 이동하도록 반복문 구성
    p = p_head->p_next; // p_head->p_next 값을 포인터 변수 p에 보관
    free(p_head); // 포인터 변수 p_head가 가리키는 노드 삭제
    p_head = p; // 다음 노드로 옮김
}
p_tail = p_head; // 반복문을 빠져나오면 p_head 값은 NULL이므로 p_tail 값도 NULL로 변경함 
```

### 연결 리스트의 종류

#### 1. 단일 연결 리스트 (Singly Linked List)

- 각 노드가 다음 노드를 가리키는 구조

- **장점**
  
  1. **동적 크기 조절**
     
     + 배열처럼 고정 크기가 아니어서 필요할 때마다 노드를 추가할 수 있음
     
     + 삽입/삭제 시 메모리 재할당(`realloc`) 필요 없음
  
  2. **삽입/삭제에 효율적**
     
     + 특정 위치(특히 맨 앞) 삽입/삭제 가능
     
     + 배열처럼 모든 요소를 뒤로 밀 필요가 없음
  
  3. **메모리 효율**
     
     + 필요한 만큼만 노드 할당

- **단점**
  
  1. **임의 접근 불가능**
     
     + 인덱스로 바로 접근 못 함
     + ex) 배열은 arr[100] 바로 접근 가능하지만, 단일 연결 리스트는 100번째까지 걸어가야 함
  
  2. **추가 메모리 사용**
     
     + 각 노드마다 next 포인터를 저장해야 함
  
  3. **역방향 탐색 불가**
     
     + 이전 노드를 가리키는 정보가 없으므로, 뒤에서 앞으로 갈 수 없음
       
       + 이중 연결 리스트로 해결 가능
  
  4. **캐시 효율 낮음**
     
     + 노드가 메모리상 연속 배치되지 않으므로, 배열보다 CPU 캐시 활용도가 낮음
       + 캐시 활용도: 데이터가 CPU 캐시(메모리 접근 속도 차이를 줄이는 역할을 함)에 정확하고 빠르게 접근하는 정도
  
  5. **삭제 시 이전 노드 필요**
     
     + 특정 노드를 삭제하려면 반드시 이전 노드를 열어야 함 (탐색+삭제)

#### 2. 이중 연결 리스트 (Doubly Linked List)

+ (해당 내용은 double-linked-list 파일에 있는 README.md에서 설명)

## 구현된 기능

- **리스트 생성**: `ll_create()`

- **불변식 검사**: `ll_check_invariants()`

- **빈 리스트 여부 확인**: `ll_is_empty()`

- **맨 앞/뒤 삽입**: `ll_push_front()`, `ll_push_back()`

- **맨 앞/뒤 삭제**: `ll_pop_front()`, `ll_pop_back()`

- **값 탐색**: `ll_find()`

- **전체 출력**: `ll_print()`

- **메모리 해제**: `ll_free() `

## 테스트

**1. 리스트 생성 테스트**

- 빈 리스트 생성 확인
- 초기 상태에서 `ll_is_empty()` 결과 확인
- 빈 리스트 출력 테스트

**2. 맨 앞 삽입 테스트 (`ll_push_front`)**

- 10 삽입 후 리스트 상태
- 20 삽입 후 리스트 상태

**3. 맨 뒤 삽입 테스트 (`ll_push_back`)**

- 5 삽입 후 리스트 상태
- 1 삽입 후 리스트 상태

**4. 값 탐색 테스트 (`ll_find`)**

- 존재하는 값 탐색
- 존재하지 않는 값 탐색

**5. 맨 앞 삭제 테스트 (`ll_pop_front`)**

- 삭제 후 상태
- 값 반환 확인

**6. 맨 뒤 삭제 테스트 (`ll_pop_back`)**

- 삭제 후 상태

**7. 경계 조건 테스트 - 모든 요소 삭제**

- `ll_is_empty()`가 false인 동안 반복 삭제
- 각 삭제마다 남은 요소 출력
- 완전히 비워질 때까지 진행
- 최종 빈 리스트 상태 확인

**8. 에러 상황 테스트 - 빈 리스트에서 삭제**

- 빈 리스트에서 `ll_pop_front()` 호출
- 빈 리스트에서 `ll_pop_back()` 호출

**9. 단일 노드 테스트**

- 99 하나만 삽입
- 단일 노드에서 `ll_pop_back()` 실행

**10. 복합 연산 테스트**

- 1부터 5까지 10배수를 맨 뒤 삽입
- 100, 200을 맨 앞 삽입
- 존재하는 값 탐색
- 존재하지 않는 값 탐색

**11. 불변식 검사 테스트**

- 모든 삽입/삭제 연산 후 `ll_check_invariants()` 자동 실행
- 에러 메시지가 없으면 데이터 구조가 올바르게 유지됨을 확인

**12. 메모리 해제 테스트**

- `ll_free()` 함수로 모든 노드 메모리 해제
- 해제 후 빈 리스트 출력으로 정상 처리 확인

**13. NULL 포인터 안전성 테스트**

- NULL 리스트에 대한 모든 연산 테스트
- `ll_push_front(NULL, 10)`, `ll_push_back(NULL, 10)` 테스트
- `ll_pop_front(NULL, &value)`, `ll_pop_back(NULL, &value)` 테스트
- `ll_print(NULL)` 테스트
