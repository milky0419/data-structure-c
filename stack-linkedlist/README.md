[README.md](https://github.com/user-attachments/files/21766986/README.sll.md)
# 연결 리스트 기반 스택 (Stack-Linkedlist)

## 개념

### 1. 특징

+ 스택(stack)이므로 **후입선출(LIFO, Last In First Out) 구조**
- 데이터를 저장하는 배열이 아니기 때문에 **노드**를 **동적으로 만들어 연결**해서 **구성**

- 삽입(`push`)과 삭제(`pop`)는 **맨 앞(head)**에서만 일어남

### 2. 구조

```c
typedef struct StackNode {
    int data;
    struct StackNode* next;
} StackNode;

typedef struct {
    StackNode* top; // 스택의 맨 위 노드
} Stack;
```

- `top`이 연결 리스트의 **head 역할**

- `top == NULL` → 스택이 비어있음

### 3. 주요 연산

| 연산         | 동작              | 비고            |
| ---------- | --------------- | ------------- |
| `push`     | 새 노드를 top 앞에 추가 | 새 노드가 top이 됨  |
| `pop`      | top 노드 제거 후 반환  | top 갱신 필요     |
| `peek`     | top 노드의 값 확인    | 삭제는 안 함       |
| `is_empty` | top이 NULL인지 확인  |               |
| `free`     | 모든 노드 해제        | 반복적으로 free 필요 |

### 4. 장단점

- 장점
  
  + 배열과 달리 **크기 제한 없음** (필요할 때마다 malloc)
  
  + 메모리를 **효율적**으로 사용 (필요한 만큼만 사용)

- 단점
  
  + **연속된 메모리**가 아니라서 **CPU 캐시 효율이 낮음**
  
  + 메모리 **단편화 가능성 있**음 (malloc을 반복적으로 사용하면 메모리의 연속성이 깨질 수 있음)

## 구현된 기능

- 빈 스택 생성 및 초기화: `sl_create()`

- 데이터 삽입: `sl_push()`

- 데이터 제거 및 반환: `sl_pop()`

- 최상단 확인: `sl_peek()`

- 비어 있는지 확인: `sl_is_empty()`

- 현재 저장된 요소 개수 반환: `sl_size()`

- 스택 내용 출력 (top -> bottom 순서): `sl_print()`

- 모든 노드 해제 및 top 초기화: `sl_free()`

- 연결 리스트 무결성과 순환 참조 검증 (자동 실행): `sl_check_invariants()`

## 테스트

### 1. 스택 생성 테스트

- 빈 스택 생성 확인
- 초기 상태에서 비어있음 확인
- 초기 크기 확인

### 2. push 기본 테스트

- 10, 20, 30 순서로 push 연산
- 각 push 후 성공/실패 결과 확인
- push 후 스택 상태 및 크기 출력

### 3. peek 테스트

- 최상단 요소 확인 (스택 변경 없음)
- peek 전후 스택 상태 비교
- out 파라미터를 통한 값 반환 확인

### 4. pop 기본 테스트

- 최상단 요소 제거 및 값 반환
- pop 전후 스택 상태 비교
- out 파라미터를 통한 값 반환 확인

### 5. 스택 상태 확인 테스트

- 현재 스택 크기 확인
- 비어있음 상태 확인
- 스택 내용 출력

### 6. 동적 확장 테스트

- 배열과 달리 크기 제한 없음을 확인
- 많은 요소 추가 (100부터 150까지 5씩 증가)
- 추가된 요소 개수 및 최종 크기 확인
- 전체 스택 내용 출력

### 7. 메모리 할당 확인 테스트

- 더 많은 요소 추가 시도 (1000부터 1020까지)
- 메모리 할당 성공/실패 확인
- 대량 데이터 처리 시 상위 몇 개 요소만 출력
- 총 크기 확인

### 8. 모든 요소 pop 테스트

- 스택이 빌 때까지 모든 요소 제거
- pop된 요소 개수 확인
- 처음 5개와 10개마다 진행 상황 출력
- 최종 빈 스택 상태 확인

### 9. 언더플로우 테스트

- 빈 스택에서 pop 시도
- 빈 스택에서 peek 시도
- 언더플로우 상황에서 실패 처리 확인

### 10. LIFO 특성 테스트

- 100, 200, 300 순서로 push
- pop 순서가 300, 200, 100인지 확인
- Last In First Out 동작 검증

### 11. 연결 리스트 특성 테스트

- 배열 기반과 달리 이론적으로 크기 제한이 없음 확인
- 15개 요소 추가 (7의 배수들)
- 일부 요소 제거 후 크기 변화 확인
- 동적 크기 조절 특성 검증

### 12. 불변식 검사 테스트

- 현재 스택 상태에서 불변식 검사
- 모든 push/pop 연산 후 `sl_check_invariants()` 자동 실행
- 연결 리스트 무결성 검증
- 순환 참조 방지 검사
- 에러 메시지가 없으면 데이터 구조가 올바르게 유지됨을 확인

### 13. 메모리 해제 테스트

- `sl_free()` 함수로 모든 노드 메모리 해제
- 해제 후 빈 스택 상태 확인
- 해제 후 크기 확인
- 댕글링 포인터 방지 확인

### 14. NULL 포인터 안전성 테스트

- NULL 스택에 대한 모든 연산 테스트
- `sl_push(NULL, 10)`, `sl_pop(NULL, &value)`, `sl_peek(NULL, &value)` 안전 처리
- `sl_print(NULL)` 적절한 메시지 출력
