[README.md](https://github.com/user-attachments/files/21873588/README.dll.md)
# 이중 연결 리스트 (Doubly Linked List)

## 개념

### 단일 연결 리스트와의 차이점

#### 1. 구조 차이

| 항목           | 단일 연결 리스트(SLL)      | 이중 연결 리스트(DLL)           |
| ------------ | ------------------- | ------------------------ |
| 노드 구성        | `data` + `next`     | `data` + `prev` + `next` |
| 방향           | 한 방향(다음 노드로만 이동 가능) | 양방향(이전·다음 노드로 이동 가능)     |
| 탐색 방향        | head → tail 한 방향만   | head ↔ tail 양쪽 방향 모두 가능  |
| tail에서 head로 | 불가능                 | 가능                       |

#### 2. 동작 차이

| 항목    | SLL         | DLL                                        |
|:----- |:----------- |:------------------------------------------ |
| 중간 삽입 | 이전 노드 주소 필요 | 이전 노드 없어도`prev`를 사용해서 삽입 위치 양쪽을 쉽게 연결      |
| 중간 삭제 | 이전 노드 주소 필요 | `prev`가 있기 때문에 이전 노드를 찾기 위해 반복문을 사용할 필요 없음 |

#### 3. 장단점 및 적합한 경우 비교

| 항목         | SLL                         | DLL                          |
| ---------- | --------------------------- | ---------------------------- |
| **장점**     | 메모리 절약 (포인터 한 개), 구조 단순     | 양방향 이동 가능, 중간 노드 삭제/삽입 효율적   |
| **단점**     | 이전 노드 접근 불가                 | 포인터 두 개로 메모리 사용량 증가          |
| **적합한 경우** | 단방향 순회 위주 작업, 메모리 제약이 심한 경우 | 양방향 순회 필요, 중간 삽입/삭제 자주 하는 경우 |

## 구현된 기능

- **리스트 생성**: `dll_create()`

- **데이터 무결성 검사**: `dll_check_invariants()`

- **빈 리스트 여부 확인**: `dll_is_empty()`

- **맨 앞/뒤 삽입**: `dll_push_front()`, `dll_push_back()`

- **맨 앞/뒤 삭제**: `dll_pop_front()`, `dll_pop_back()`

- **값 탐색**: `dll_find()`

- **앞에서 뒤로 전체 출력**: `dll_print_forward()`

- **뒤에서 앞으로 전체 출력**: `dll_print_backward()`

- **메모리 해제**: `dll_free()`

## 테스트

**1. 리스트 생성 테스트**

- 빈 리스트 생성 확인
- 초기 상태에서 `dll_is_empty()` 결과 확인
- 빈 리스트 양방향 출력 테스트

**2. 맨 앞 삽입 테스트 (`dll_push_front`)**

- 10 삽입 후 양방향 출력
- 20 삽입 후 양방향 출력

**3. 맨 뒤 삽입 테스트 (`dll_push_back`)**

- 5 삽입 후 양방향 출력
- 1 삽입 후 양방향 출력

**4. 값 탐색 테스트 (`dll_find`)**

- 존재하는 값 탐색
- 존재하지 않는 값 탐색

**5. 맨 앞 삭제 테스트 (`dll_pop_front`)**

- 맨 앞 요소 삭제 후 양방향 출력

**6. 맨 뒤 삭제 테스트 (`dll_pop_back`)**

- 맨 뒤 요소 삭제 후 양방향 출력

**7. 양방향 출력 집중 테스트**

- 50을 맨 앞, 100과 200 맨 뒤 삽입 후 양방향 출력

**8. 경계 조건 테스트 - 모든 요소 삭제**

- `dll_is_empty()`가 false인 동안 반복 삭제
- 각 삭제마다 남은 요소 앞->뒤로 출력
- 완전히 비워질 때까지 진행
- 최종 빈 리스트 상태에서 양방향 출력

**9. 에러 상황 테스트 - 빈 리스트에서 삭제**

- 빈 리스트에서 `dll_pop_front()` 호출
- 빈 리스트에서 `dll_pop_back()` 호출

**10. 단일 노드 테스트**

- 하나만 삽입
- 단일 노드에서 삭제 연산 실행
- 단일 노드에서 양방향 출력

**11. 이중 연결 특성 집중 테스트**

- 앞/뒤 삽입 혼합
- 앞 삭제 후, 뒤 삭제

**12. 불변식 검사 테스트**

- 양방향 연결 일관성 검증
- 에러 메시지가 없으면 데이터 구조가 올바르게 유지됨을 확인

**13. 메모리 해제 테스트**

- `dll_free()` 함수로 모든 노드 메모리 해제
- 해제 후 빈 리스트에서 양방향 출력으로 정상 처리 확인

**14. NULL 포인터 안전성 테스트**

- NULL 리스트에 대한 모든 연산 테스트
- `dll_push_front(NULL, 10)`, `dll_push_back(NULL, 10)` 테스트
- `dll_pop_front(NULL, &value)`, `dll_pop_back(NULL, &value)` 테스트
- `dll_print_forward(NULL)`, `dll_print_backward(NULL)` 테스트
