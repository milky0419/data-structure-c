[README.md](https://github.com/user-attachments/files/21739671/README.dll.md)
# 이중 연결 리스트 (Doublt Linked List)

## 개념

### 단일 연결 리스트와의 차이점

#### 1. 구조 차이

| 항목           | 단일 연결 리스트(SLL)      | 이중 연결 리스트(DLL)           |
| ------------ | ------------------- | ------------------------ |
| 노드 구성        | `data` + `next`     | `data` + `prev` + `next` |
| 방향           | 한 방향(다음 노드로만 이동 가능) | 양방향(이전·다음 노드로 이동 가능)     |
| 탐색 방향        | head → tail 한 방향만   | head ↔ tail 양쪽 방향 모두 가능  |
| tail에서 head로 | 불가능                 | 가능                       |

#### 2. 동작 차이

| 항목    | SLL         | DLL                                        |
|:----- |:----------- |:------------------------------------------ |
| 중간 삽입 | 이전 노드 주소 필요 | 이전 노드 없어도`prev`를 사용해서 삽입 위치 양쪽을 쉽게 연결      |
| 중간 삭제 | 이전 노드 주소 필요 | `prev`가 있기 때문에 이전 노드를 찾기 위해 반복문을 사용할 필요 없음 |

#### 3. 장단점 및 적합한 경우 비교

| 항목         | SLL                         | DLL                          |
| ---------- | --------------------------- | ---------------------------- |
| **장점**     | 메모리 절약 (포인터 1개), 구조 단순      | 양방향 이동 가능, 중간 노드 삭제·삽입 효율적   |
| **단점**     | 이전 노드 접근 불가                 | 포인터 2개로 메모리 사용량 증가           |
| **적합한 경우** | 단방향 순회 위주 작업, 메모리 제약이 심한 경우 | 양방향 순회 필요, 중간 삽입/삭제 자주 하는 경우 |

## 구현된 기능

- **리스트 생성**: `dll_create()`
- **맨 앞/뒤 삽입**: `dll_push_front()`, `dll_push_back()`
- **맨 앞/뒤 삭제**: `dll_pop_front()`, `dll_pop_back()`

- **값 탐색**: `dll_find()`
- **앞에서 뒤로 전체 출력**: `dll_print_forward()`
- **뒤에서 앞으로 전체 출력**: `dll_print_backward()`
- **빈 리스트 여부 확인**: `dll_is_empty()`

- **메모리 해제**: `dll_free()`

- **데이터 무결성 검사**: `dll_check_invariants()`

## 테스트

**1. 리스트 생성 테스트**

- 빈 리스트 생성 확인
- 초기 상태에서 `dll_is_empty()` 결과 확인
- 빈 리스트에서 양방향 출력 테스트

**2. 맨 앞 삽입 테스트 (`dll_push_front`)**

- 10, 20 순서로 맨 앞 삽입
- 앞→뒤, 뒤→앞 출력으로 양방향 연결 확인

**3. 맨 뒤 삽입 테스트 (`dll_push_back`)**

- 5, 1 순서로 맨 뒤 삽입
- tail 포인터와 양방향 연결 정상 동작 확인

**4. 값 탐색 테스트 (`dll_find`)**

- 존재하는 값 탐색: 10, 5 검색 성공
- 존재하지 않는 값 탐색: 100 검색 실패
- NULL 반환 처리 확인

**5. 맨 앞 삭제 테스트 (`dll_pop_front`)**

- 현재 리스트에서 맨 앞 요소 삭제
- 삭제된 값의 out 파라미터 반환 확인
- 새로운 head의 prev 포인터가 NULL인지 확인

**6. 맨 뒤 삭제 테스트 (`dll_pop_back`)**

- 현재 리스트에서 맨 뒤 요소 삭제
- 삭제된 값의 out 파라미터 반환 확인
- 새로운 tail의 next 포인터가 NULL인지 확인

**7. 양방향 출력 집중 테스트**

- 50을 맨 앞, 100과 200을 맨 뒤 삽입
- 앞→뒤, 뒤→앞 양방향 출력 실행
- 양방향 출력의 대칭성 확인

**8. 경계 조건 테스트 - 모든 요소 삭제**

- `dll_is_empty()`가 false인 동안 반복 삭제
- 각 삭제마다 남은 요소 출력
- 완전히 비워질 때까지 진행
- 최종 빈 리스트 상태에서 양방향 출력 확인

**9. 에러 상황 테스트 - 빈 리스트에서 삭제**

- 빈 리스트에서 `dll_pop_front()` 호출
- 빈 리스트에서 `dll_pop_back()` 호출
- 안전한 에러 처리 확인

**10. 단일 노드 테스트**

- 하나만 삽입
- 단일 노드에서 양방향 출력 확인
- 단일 노드에서 삭제 연산 실행
- head와 tail이 동일한 노드를 가리킬 때의 처리 확인

**11. 이중 연결 특성 집중 테스트**

- 앞뒤 삽입 혼합
- 양방향 출력으로 올바른 연결 확인
- 앞뒤 삭제 혼합: 앞 삭제, 뒤 삭제 실행
- 혼합 연산 후에도 양방향 연결 유지 확인

**12. 불변식 검사 테스트**

- 모든 삽입/삭제 연산 후 `dll_check_invariants()` 자동 실행
- 양방향 연결 일관성: `node->next->prev == node` 검증
- 경계 조건: `head->prev == NULL`, `tail->next == NULL` 검증
- 에러 메시지가 없으면 데이터 구조가 올바르게 유지됨을 확인

**13. 메모리 해제 테스트**

- `dll_free()` 함수로 모든 노드 메모리 해제
- 해제 후 빈 리스트에서 양방향 출력으로 정상 처리 확인
- 댕글링 포인터 방지

**14. NULL 포인터 안전성 테스트**

- NULL 리스트에 대한 모든 연산 테스트
- `dll_push_front(NULL, 10)`, `dll_push_back(NULL, 10)` 
- `dll_pop_front(NULL, &value)`, `dll_pop_back(NULL, &value)` 
- `dll_print_forward(NULL)`, `dll_print_backward(NULL)`
